function RSAGenerateGLM(EVfile, subjectTag, outputFolder)
    % Load design generated by SPMGenerateEVs and specify and run GLM in SPM
    
    % Set default home dir for execution on cluster
    homeDir = '/home/fs0/jacobb';
    if ~exist(homeDir,'dir')
        % If not called on cluster, but working on laptop connected to server
        homeDir = '/Volumes/jacobb';
    end
    if ~exist(homeDir,'dir')
        % If not called on laptop, but on mac desktop connected to server
        homeDir = '/Users/jacobb/Documents/ServerHome';
    end
    
    % Set default home dir for execution on cluster
    scratchDir = '/home/fs0/jacobb/scratch';
    if ~exist(scratchDir,'dir')
        % If not called on cluster, but working on laptop connected to server
        scratchDir = '/Volumes/Scratch_jacobb';
    end
    if ~exist(scratchDir,'dir')
        % If not called on laptop, but on mac desktop connected to server
        scratchDir = '/Users/jacobb/Documents/ServerHome/scratch';
    end
    
    % Set path of SPM installation
    spmPath = fullfile(scratchDir,'matlab','spm12');
    % Add SPM and all subdirectories to Matlab
    addpath(genpath(spmPath));
    % Base directory of fMRI data
    derivDir = fullfile(scratchDir,'derivatives',['sub-' subjectTag]);
    % Directory of preprocessed functional data
    preprocDir = fullfile(derivDir,'func','preproc_nosmooth.feat');
    % Get directory of input file with EVS
    [inputDir,~,~] = fileparts(EVfile);
    
    % Select all .nii files in data folder (arguments: 'full path list', directory, filter)
    [pathList] = spm_select('FPList', fullfile(preprocDir,'filtered_func_data_split'),'^*.*.nii$');
    pathList = mat2cell(pathList, ones(size(pathList,1),1));        
    
    % Set mask for GLM, can use the one generated by FSL in preprocessing
    mask = fullfile(preprocDir, 'mask.nii'); % Careful! This should be a .nii file, not .nii.gz
    
    % Load motion parameters generated by FSL
    motion = load(fullfile(preprocDir,'mc','prefiltered_func_data_mcf.par'));
    motionNames = {'roll','yaw','pitch','x','y','z'}; % This was wrong! FSL saves angles (in rad) first, then translation
    % Create structure for motion parameters with names that SPM expects
    motionStruct = struct();
    motionStruct.names = motionNames;
    motionStruct.R = motion;
    % Save motion parameters in mat file, in folder of input file
    save(fullfile(inputDir,'mc.mat'),'-struct','motionStruct');    
    
    % Number of slices in z-direction
    slices = 72;
    % TR in seconds
    TR = 1.235;
    
    % Create structure with all parameters for SPM to run
    params = struct();
    params.dir = {outputFolder}; % Directory for output
    params.fact = struct('name', {}, 'levels', {}); %?
    params.bases.hrf.derivs = [1 0]; % Temporal and dispersion derivatives
    params.volt = 1; %?
    params.global = 'None'; %?
    params.mthresh = 0.000001; %? If using mask file, set this very low
    params.mask = {[mask, ',1']}; % Brain mask in functional space
    params.cvi = 'fast'; % Autocorrelation correction    
    % Set timing parameters
    params.timing.units = 'secs'; % Units for timing (e.g. in EVs)
    params.timing.RT = TR; % Experiment TR
    params.timing.fmri_t = slices; % 'Microtime resolution': time-bins per scan = number of slices in z direction
    params.timing.fmri_t0 = 1; % 'Microtime onset': time bin at which regressors coincide with data acquisition = first slice (trigger recording time)
    % Session specific parameters - I have only one session
    params.sess(1).scans = pathList; % List of file paths for all volumes
    params.sess(1).nscans = length(pathList); % Number of volumes
    params.sess(1).cond = struct('name', {}, 'onset', {}, 'duration', {}); % Single condition is set to empty
    params.sess(1).multi = {EVfile}; % Multiple conditions: path to file with EVs
    params.sess(1).regress = struct('name', {}, 'val', {}); %?
    params.sess(1).multi_reg = {fullfile(inputDir,'mc.mat')}; % Path to motion parameters file
    params.sess(1).hpf = inf; % High pass filter. Set to inf, since we don't want high pass filtering: already done in FSL preprocessing
    
    % First batch: model specification
    matlabbatch{1}.spm.stats.fmri_spec = params;
    % Second batch: model estimation
    matlabbatch{2}.spm.stats.fmri_est.spmmat = {fullfile(outputFolder, 'SPM.mat')};
    matlabbatch{2}.spm.stats.fmri_est.method.Classical = 1;
    % Run model specification and estimation
    disp('Running specification and estimation...');    
    spm_jobman('run',matlabbatch);         
end